# filepath: c:\Personal\chemouflage-card-shop\backend\app\repositories\user.py.new
from datetime import datetime
from typing import List, Optional, Dict, Any

from app.db.firebase import get_firestore_db
from app.models.user import (User, UserCreate, UserInDB, UserProfile, UserRole,
                           UserRoleCreate, UserRoleInDB, UserUpdate)
from google.cloud.firestore import FieldFilter
import uuid


class UserRepository:
    COLLECTION = "users"
    
    @staticmethod
    def _convert_to_user(doc_dict: Dict[str, Any]) -> User:
        """Convert Firestore document to User model"""
        user_dict = doc_dict.copy()
        user_dict["id"] = user_dict.pop("doc_id")
        return User(**user_dict)
    
    @staticmethod
    async def create(user: UserCreate) -> str:
        """Create a new user in Firestore"""
        db = get_firestore_db()
        
        # Check if user already exists
        users_ref = db.collection(UserRepository.COLLECTION)
        existing_users = users_ref.where(filter=FieldFilter("email", "==", user.email.lower())).limit(1).stream()
        
        if list(existing_users):
            raise ValueError("Email already registered")
        
        # Create the user
        user_dict = user.model_dump()
        
        # Handle password if present (for admin-created users)
        if user.password:
            from app.core.security import get_password_hash
            hashed_password = get_password_hash(user_dict.pop("password"))
            user_dict["hashed_password"] = hashed_password
        
        user_dict["email"] = user_dict["email"].lower()
        user_dict["created_at"] = datetime.utcnow()
        
        # Generate document ID
        doc_id = str(uuid.uuid4())
        
        # Add the document
        users_ref.document(doc_id).set(user_dict)
        
        return doc_id
    
    @staticmethod
    async def create_from_firebase(user_data: Dict[str, Any]) -> str:
        """Create a user from Firebase Auth"""
        db = get_firestore_db()
        
        # Check if user already exists by Firebase UID
        users_ref = db.collection(UserRepository.COLLECTION)
        existing_users = users_ref.where(filter=FieldFilter("firebase_uid", "==", user_data["firebase_uid"])).limit(1).stream()
        
        existing_user = next(existing_users, None)
        if existing_user:
            return existing_user.id
            
        # Check if user exists by email
        email_users = users_ref.where(filter=FieldFilter("email", "==", user_data["email"].lower())).limit(1).stream()
        email_user = next(email_users, None)
        
        if email_user:
            # Update existing user with Firebase UID
            email_user_ref = users_ref.document(email_user.id)
            email_user_ref.update({
                "firebase_uid": user_data["firebase_uid"],
                "updated_at": datetime.utcnow()
            })
            return email_user.id
        
        # Create a new user
        user_dict = user_data.copy()
        user_dict["email"] = user_dict["email"].lower()
        user_dict["created_at"] = datetime.utcnow()
        
        # Generate document ID
        doc_id = str(uuid.uuid4())
        
        # Add the document
        users_ref.document(doc_id).set(user_dict)
        
        return doc_id
    
    @staticmethod
    async def get_by_id(user_id: str) -> Optional[User]:
        """Get user by ID"""
        db = get_firestore_db()
        doc_ref = db.collection(UserRepository.COLLECTION).document(user_id)
        doc = doc_ref.get()
        
        if doc.exists:
            user_dict = doc.to_dict()
            user_dict["doc_id"] = doc.id
            return UserRepository._convert_to_user(user_dict)
        
        return None
    
    @staticmethod
    async def get_by_firebase_uid(firebase_uid: str) -> Optional[User]:
        """Get user by Firebase UID"""
        db = get_firestore_db()
        users_ref = db.collection(UserRepository.COLLECTION)
        query = users_ref.where(filter=FieldFilter("firebase_uid", "==", firebase_uid)).limit(1)
        
        docs = query.stream()
        doc = next(docs, None)
        
        if doc:
            user_dict = doc.to_dict()
            user_dict["doc_id"] = doc.id
            return UserRepository._convert_to_user(user_dict)
        
        return None
    
    @staticmethod
    async def get_by_email(email: str) -> Optional[User]:
        """Get user by email"""
        db = get_firestore_db()
        users_ref = db.collection(UserRepository.COLLECTION)
        query = users_ref.where(filter=FieldFilter("email", "==", email.lower())).limit(1)
        
        docs = query.stream()
        doc = next(docs, None)
        
        if doc:
            user_dict = doc.to_dict()
            user_dict["doc_id"] = doc.id
            return UserRepository._convert_to_user(user_dict)
        
        return None
    
    @staticmethod
    async def update(user_id: str, user_update: UserUpdate) -> bool:
        """Update user"""
        db = get_firestore_db()
        doc_ref = db.collection(UserRepository.COLLECTION).document(user_id)
        
        # Check if user exists
        doc = doc_ref.get()
        if not doc.exists:
            return False
        
        # Update user
        update_dict = user_update.model_dump(exclude_unset=True)
        update_dict["updated_at"] = datetime.utcnow()
        
        doc_ref.update(update_dict)
        return True
    
    @staticmethod
    async def delete(user_id: str) -> bool:
        """Delete user"""
        db = get_firestore_db()
        doc_ref = db.collection(UserRepository.COLLECTION).document(user_id)
        
        # Check if user exists
        doc = doc_ref.get()
        if not doc.exists:
            return False
        
        # Delete user
        doc_ref.delete()
        return True
    
    @staticmethod
    async def get_all(skip: int = 0, limit: int = 100) -> List[User]:
        """Get all users with pagination"""
        db = get_firestore_db()
        users_ref = db.collection(UserRepository.COLLECTION)
        
        # Get total count first (for proper pagination)
        all_users = list(users_ref.stream())
        total_count = len(all_users)
        
        # Apply pagination
        start = min(skip, total_count)
        end = min(skip + limit, total_count)
        
        result = []
        for i in range(start, end):
            doc = all_users[i]
            user_dict = doc.to_dict()
            user_dict["doc_id"] = doc.id
            result.append(UserRepository._convert_to_user(user_dict))
        
        return result
    
    @staticmethod
    async def get_profile(user_id: str) -> Optional[UserProfile]:
        """Get user profile with role"""
        user = await UserRepository.get_by_id(user_id)
        if not user:
            return None
        
        # Get user role
        role = await UserRoleRepository.get_by_user_id(user_id)
        
        # Create profile
        profile_dict = user.model_dump()
        profile_dict["role"] = role
        
        return UserProfile(**profile_dict)
    
    @staticmethod
    async def authenticate(email: str, password: str) -> Optional[User]:
        """Authenticate a user with email and password"""
        from app.core.security import verify_password
        
        user = await UserRepository.get_by_email(email)
        if not user:
            return None
        
        # If user was created via Firebase, they won't have a password
        if not hasattr(user, "hashed_password") or not user.hashed_password:
            return None
        
        # Verify password
        db = get_firestore_db()
        doc_ref = db.collection(UserRepository.COLLECTION).document(user.id)
        doc = doc_ref.get()
        user_dict = doc.to_dict()
        
        if not verify_password(password, user_dict.get("hashed_password", "")):
            return None
        
        return user


class UserRoleRepository:
    COLLECTION = "user_roles"
    
    @staticmethod
    def _convert_to_user_role(doc_dict: Dict[str, Any]) -> UserRole:
        """Convert Firestore document to UserRole model"""
        role_dict = doc_dict.copy()
        role_dict["id"] = role_dict.pop("doc_id")
        role_dict["user_id"] = role_dict["user_id"]  # Already a string in Firestore
        return UserRole(**role_dict)
    
    @staticmethod
    async def create(role: UserRoleCreate) -> str:
        """Create a new user role"""
        db = get_firestore_db()
        
        # Check if role already exists
        roles_ref = db.collection(UserRoleRepository.COLLECTION)
        existing_roles = roles_ref.where(filter=FieldFilter("user_id", "==", role.user_id)).limit(1).stream()
        
        if list(existing_roles):
            raise ValueError("Role already exists for this user")
        
        # Create role
        role_dict = role.model_dump()
        role_dict["created_at"] = datetime.utcnow()
        
        # Generate document ID
        doc_id = str(uuid.uuid4())
        
        # Add the document
        roles_ref.document(doc_id).set(role_dict)
        
        return doc_id
    
    @staticmethod
    async def get_by_id(role_id: str) -> Optional[UserRole]:
        """Get role by ID"""
        db = get_firestore_db()
        doc_ref = db.collection(UserRoleRepository.COLLECTION).document(role_id)
        doc = doc_ref.get()
        
        if doc.exists:
            role_dict = doc.to_dict()
            role_dict["doc_id"] = doc.id
            return UserRoleRepository._convert_to_user_role(role_dict)
        
        return None
    
    @staticmethod
    async def get_by_user_id(user_id: str) -> Optional[UserRole]:
        """Get role by user ID"""
        db = get_firestore_db()
        roles_ref = db.collection(UserRoleRepository.COLLECTION)
        query = roles_ref.where(filter=FieldFilter("user_id", "==", user_id)).limit(1)
        
        docs = query.stream()
        doc = next(docs, None)
        
        if doc:
            role_dict = doc.to_dict()
            role_dict["doc_id"] = doc.id
            return UserRoleRepository._convert_to_user_role(role_dict)
        
        return None
    
    @staticmethod
    async def update(user_id: str, role_update: Dict[str, Any]) -> bool:
        """Update user role"""
        db = get_firestore_db()
        roles_ref = db.collection(UserRoleRepository.COLLECTION)
        query = roles_ref.where(filter=FieldFilter("user_id", "==", user_id)).limit(1)
        
        docs = query.stream()
        doc = next(docs, None)
        
        if not doc:
            return False
        
        # Update role
        update_dict = role_update.copy()
        update_dict["updated_at"] = datetime.utcnow()
        
        doc_ref = roles_ref.document(doc.id)
        doc_ref.update(update_dict)
        return True
    
    @staticmethod
    async def is_admin(user_id: str) -> bool:
        """Check if user is admin"""
        role = await UserRoleRepository.get_by_user_id(user_id)
        return role is not None and role.is_admin
